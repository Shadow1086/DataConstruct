# 数据结构常见写法总结

## 目录
1. [顺序表（顺序存储）](#顺序表)
2. [单链表（链式存储）](#单链表)
3. [双链表](#双链表)
4. [循环链表](#循环链表)
5. [时间复杂度对比](#时间复杂度对比)

---

## 顺序表

### 1. 数据结构定义
```cpp
#define MAXSIZE 100
typedef int ElemType;

typedef struct {
    ElemType *elem;     // 存储空间基地址（指向动态分配的数组）
    int length;         // 当前长度
} SqList;
```

### 2. 初始化
```cpp
void InitList(SqList &L) {
    L.elem = new ElemType[MAXSIZE];  // 动态分配数组空间
    if (!L.elem) exit(1);             // 分配失败则退出
    L.length = 0;                     // 初始长度为0
}
```

### 3. 插入元素（在第i个位置插入元素e）
```cpp
bool InsertElem(SqList &L, int i, ElemType e) {
    // 参数检查
    if (i < 1 || i > L.length + 1) return false;  // 位置不合法
    if (L.length >= MAXSIZE) return false;        // 表已满
    
    // 后移元素，为新元素腾出位置
    for (int j = L.length - 1; j >= i - 1; j--) {
        L.elem[j + 1] = L.elem[j];
    }
    
    // 插入新元素
    L.elem[i - 1] = e;
    L.length++;
    return true;
}
```

**图示**：
```
原始: [1, 2, 3, 4, 5], 在位置2插入99
步骤1: [1, 2, 3, 4, _, 5]  // 后移
步骤2: [1, 2, 3, _, 4, 5]  // 后移
步骤3: [1, 2, _, 3, 4, 5]  // 后移
结果: [1, 99, 2, 3, 4, 5]  // 插入
```

### 4. 删除元素（删除第i个位置的元素）
```cpp
bool DeleteElem(SqList &L, int i, ElemType &e) {
    // 参数检查
    if (i < 1 || i > L.length) return false;
    
    // 保存被删除的元素
    e = L.elem[i - 1];
    
    // 前移元素，覆盖被删除的元素
    for (int j = i; j < L.length; j++) {
        L.elem[j - 1] = L.elem[j];
    }
    
    L.length--;
    return true;
}
```

### 5. 查找元素（按值查找）
```cpp
int LocateElem(SqList L, ElemType e) {
    for (int i = 0; i < L.length; i++) {
        if (L.elem[i] == e) return i + 1;  // 返回位置（从1开始）
    }
    return 0;  // 未找到
}
```

### 6. 获取元素（按位置获取）
```cpp
bool GetElem(SqList L, int i, ElemType &e) {
    if (i < 1 || i > L.length) return false;
    e = L.elem[i - 1];
    return true;
}
```

### 7. 销毁顺序表
```cpp
void DestroyList(SqList &L) {
    delete[] L.elem;
    L.elem = nullptr;
    L.length = 0;
}
```

### 8. 完整示例代码
```cpp
#include <iostream>
using namespace std;

#define MAXSIZE 100
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
} SqList;

void InitList(SqList &L) {
    L.elem = new ElemType[MAXSIZE];
    L.length = 0;
}

bool InsertElem(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1 || L.length >= MAXSIZE) return false;
    for (int j = L.length - 1; j >= i - 1; j--) {
        L.elem[j + 1] = L.elem[j];
    }
    L.elem[i - 1] = e;
    L.length++;
    return true;
}

void PrintList(SqList L) {
    for (int i = 0; i < L.length; i++) {
        cout << L.elem[i] << " ";
    }
    cout << endl;
}

int main() {
    SqList L;
    InitList(L);
    
    // 插入元素
    InsertElem(L, 1, 10);
    InsertElem(L, 2, 20);
    InsertElem(L, 3, 30);
    
    PrintList(L);  // 输出: 10 20 30
    
    delete[] L.elem;
    return 0;
}
```

---

## 单链表

### 1. 数据结构定义
```cpp
typedef int ElemType;

typedef struct LNode {
    ElemType data;       // 数据域
    struct LNode *next;  // 指针域
} LNode, *LinkList;
```

**图示**：
```
带头结点的单链表：
head → [头结点] → [data|next] → [data|next] → NULL
```

### 2. 初始化（带头结点）
```cpp
void InitList(LinkList &L) {
    L = new LNode;         // 创建头结点
    L->next = nullptr;     // 头结点指向空
}
```

### 3. 头插法建立链表
```cpp
void CreateList_Head(LinkList &L, int n) {
    InitList(L);
    for (int i = 0; i < n; i++) {
        LNode *p = new LNode;
        cin >> p->data;
        p->next = L->next;   // 新结点指向原首结点
        L->next = p;         // 头结点指向新结点
    }
}
```

**图示**：
```
输入: 1, 2, 3
结果: head → 3 → 2 → 1 → NULL  // 逆序
```

### 4. 尾插法建立链表
```cpp
void CreateList_Tail(LinkList &L, int n) {
    InitList(L);
    LNode *tail = L;  // 尾指针初始指向头结点
    
    for (int i = 0; i < n; i++) {
        LNode *p = new LNode;
        cin >> p->data;
        tail->next = p;   // 尾结点指向新结点
        tail = p;         // 更新尾指针
    }
    tail->next = nullptr;
}
```

**图示**：
```
输入: 1, 2, 3
结果: head → 1 → 2 → 3 → NULL  // 顺序
```

### 5. 插入元素（在第i个位置插入）
```cpp
bool InsertElem(LinkList &L, int i, ElemType e) {
    LNode *p = L;
    int j = 0;
    
    // 找到第i-1个结点
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!p || j > i - 1) return false;  // i不合法
    
    // 插入新结点
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    
    return true;
}
```

**图示**：
```
原始: head → 1 → 2 → 4 → NULL，在位置3插入3
       p指向2
步骤1: s→3, s->next = 4
步骤2: p->next = s
结果: head → 1 → 2 → 3 → 4 → NULL
```

### 6. 删除元素（删除第i个位置）
```cpp
bool DeleteElem(LinkList &L, int i, ElemType &e) {
    LNode *p = L;
    int j = 0;
    
    // 找到第i-1个结点
    while (p->next && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!(p->next) || j > i - 1) return false;
    
    // 删除结点
    LNode *q = p->next;      // q指向被删除结点
    e = q->data;
    p->next = q->next;       // 跨过q连接
    delete q;                // 释放结点
    
    return true;
}
```

### 7. 查找元素（按值查找）
```cpp
LNode* LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;  // 从首结点开始
    while (p && p->data != e) {
        p = p->next;
    }
    return p;  // 找到返回指针，否则返回NULL
}
```

### 8. 获取元素（按位置获取）
```cpp
bool GetElem(LinkList L, int i, ElemType &e) {
    LNode *p = L->next;
    int j = 1;
    
    while (p && j < i) {
        p = p->next;
        j++;
    }
    
    if (!p || j > i) return false;
    e = p->data;
    return true;
}
```

### 9. 计算链表长度
```cpp
int GetLength(LinkList L) {
    int length = 0;
    LNode *p = L->next;
    while (p) {
        length++;
        p = p->next;
    }
    return length;
}
```

### 10. 销毁链表
```cpp
void DestroyList(LinkList &L) {
    LNode *p = L;
    while (p) {
        LNode *q = p;
        p = p->next;
        delete q;
    }
    L = nullptr;
}
```

### 11. 完整示例代码
```cpp
#include <iostream>
using namespace std;

typedef int ElemType;

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

void InitList(LinkList &L) {
    L = new LNode;
    L->next = nullptr;
}

void CreateList_Tail(LinkList &L, int n) {
    InitList(L);
    LNode *tail = L;
    for (int i = 0; i < n; i++) {
        LNode *p = new LNode;
        cin >> p->data;
        tail->next = p;
        tail = p;
    }
    tail->next = nullptr;
}

void PrintList(LinkList L) {
    LNode *p = L->next;
    while (p) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

int main() {
    LinkList L;
    cout << "输入5个整数: ";
    CreateList_Tail(L, 5);
    
    cout << "链表内容: ";
    PrintList(L);
    
    return 0;
}
```

---

## 双链表

### 1. 数据结构定义
```cpp
typedef int ElemType;

typedef struct DNode {
    ElemType data;
    struct DNode *prior;  // 前驱指针
    struct DNode *next;   // 后继指针
} DNode, *DLinkList;
```

**图示**：
```
NULL ← [prior|data|next] ⇄ [prior|data|next] → NULL
```

### 2. 初始化
```cpp
void InitList(DLinkList &L) {
    L = new DNode;
    L->prior = nullptr;
    L->next = nullptr;
}
```

### 3. 插入元素（在p结点之后插入s）
```cpp
void InsertAfter(DNode *p, DNode *s) {
    s->next = p->next;       // s的后继 = p的后继
    if (p->next) {
        p->next->prior = s;  // p后继的前驱 = s
    }
    s->prior = p;            // s的前驱 = p
    p->next = s;             // p的后继 = s
}
```

**图示**：
```
原始: ... ⇄ [p] ⇄ [q] ⇄ ...
插入s后: ... ⇄ [p] ⇄ [s] ⇄ [q] ⇄ ...
```

### 4. 删除元素（删除p结点）
```cpp
void DeleteNode(DNode *p) {
    if (p->prior) {
        p->prior->next = p->next;
    }
    if (p->next) {
        p->next->prior = p->prior;
    }
    delete p;
}
```

---

## 循环链表

### 1. 循环单链表
```cpp
// 特点：尾结点的next指向头结点
void InitList(LinkList &L) {
    L = new LNode;
    L->next = L;  // 指向自己
}

// 判断是否为空
bool isEmpty(LinkList L) {
    return L->next == L;
}

// 判断是否到达表尾
bool isTail(LinkList L, LNode *p) {
    return p->next == L;
}
```

**图示**：
```
head → [1] → [2] → [3] → [4] ┐
 ↑                            │
 └────────────────────────────┘
```

### 2. 循环双链表
```cpp
void InitList(DLinkList &L) {
    L = new DNode;
    L->prior = L;
    L->next = L;
}

bool isEmpty(DLinkList L) {
    return L->next == L;
}
```

---

## 时间复杂度对比

| 操作 | 顺序表 | 单链表（不带头结点） | 单链表（带头结点） | 双链表 |
|------|--------|---------------------|-------------------|--------|
| 初始化 | O(1) | O(1) | O(1) | O(1) |
| 按位查找 | O(1) | O(n) | O(n) | O(n) |
| 按值查找 | O(n) | O(n) | O(n) | O(n) |
| 插入（头部） | O(n) | O(1) | O(1) | O(1) |
| 插入（尾部） | O(1) | O(n) | O(n) | O(1)* |
| 插入（中间） | O(n) | O(n) | O(n) | O(n) |
| 删除（头部） | O(n) | O(1) | O(1) | O(1) |
| 删除（尾部） | O(1) | O(n) | O(n) | O(1)* |
| 删除（中间） | O(n) | O(n) | O(n) | O(1)** |
| 获取长度 | O(1) | O(n) | O(n) | O(n) |

**说明**：
- `*` 需要维护尾指针
- `**` 已知要删除结点的指针时

---

## 顺序表 vs 链表 选择建议

### 选择顺序表的情况
- 需要频繁按位置访问元素
- 元素个数相对稳定
- 很少进行插入删除操作
- 内存空间连续且充足

### 选择链表的情况
- 频繁进行插入删除操作
- 元素个数变化较大
- 不需要随机访问
- 内存空间分散

---

## 常见算法题型

### 1. 顺序表去重（有序）
```cpp
void RemoveDuplicates(SqList &L) {
    if (L.length <= 1) return;
    int i = 0;
    for (int j = 1; j < L.length; j++) {
        if (L.elem[j] != L.elem[i]) {
            i++;
            L.elem[i] = L.elem[j];
        }
    }
    L.length = i + 1;
}
```

### 2. 单链表逆置
```cpp
void ReverseList(LinkList &L) {
    LNode *p = L->next;
    L->next = nullptr;
    while (p) {
        LNode *q = p->next;
        p->next = L->next;
        L->next = p;
        p = q;
    }
}
```

### 3. 合并两个有序链表
```cpp
void MergeList(LinkList La, LinkList Lb, LinkList &Lc) {
    LNode *pa = La->next;
    LNode *pb = Lb->next;
    Lc = La;  // 使用La的头结点
    LNode *pc = Lc;
    
    while (pa && pb) {
        if (pa->data <= pb->data) {
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        } else {
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        }
    }
    pc->next = pa ? pa : pb;
    delete Lb;
}
```

---

## 总结

1. **顺序表**：适合随机访问，插入删除效率低
2. **单链表**：适合频繁插入删除，查找效率低
3. **双链表**：可以双向遍历，删除操作更方便
4. **循环链表**：适合需要循环访问的场景

根据具体应用场景选择合适的数据结构！

